const N = 3
range Nodes= 0..N-1

NODE(I=N) = IDLE,
LEADER    = ( open -> close -> send.token -> IDLE
			| send.token -> IDLE),
IDLE 	  = ( recv.token -> LEADER
	   		| recv.claim[i:Nodes] ->
				if (i < I) then (send.claim[i] -> IDLE)
				else IDLE
	   		| send.claim[I] -> ELIGIBLE),
ELIGIBLE  = ( recv.token -> LEADER
		   	| recv.claim[i:Nodes] ->
		   		if (i == I) then LEADER
				else if (i < I) then (send.claim[i] -> IDLE)
				else ELIGIBLE
		   | send.claim[I] -> ELIGIBLE)
+ {send.claim[Nodes]}.


CHANNEL = (token_sent -> token_received -> CHANNEL | claim_sent[i:Nodes] -> claim_received[i] -> CHANNEL).

|| ELECTIONRING = ([a:Nodes]:NOMINALRING(a) || [b:Nodes]:CHANNEL ) / {
	[b:Nodes].send.claim[a:Nodes]/[b].claim_sent[a],
	[b:Nodes].recv.claim[a:Nodes]/[(b+N-1)%N].claim_received[a],
	[b:Nodes].send.token/[b].token_sent,
	[b:Nodes].recv.token/[(b+N-1)%N].token_received
}.

|| ELECTIONSERVICE = ELECTIONRING @ {[Nodes].open, [Nodes].close}.

minimal || ABSTRACT0 = ELECTIONRING.
minimal || ABSTRACT1 = ABSTRACT0 \ {[b:Nodes].send.claim[a:Nodes]}.
minimal || ABSTRACT2 = ABSTRACT1 \ {[b:Nodes].recv.claim[a:Nodes]}.
minimal || ABSTRACT3 = ABSTRACT2 \ {[b:Nodes].recv.token}.
minimal || ABSTRACT4 = ABSTRACT3 \ {[b:Nodes].send.token}.
