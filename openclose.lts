const N = 3
range Nodes = 0..(N-1)

/**
 * NOMINALRING
 */
NODE(I=0) = LEADER[I],
LEADER[a:Nodes] = ( [a].open -> [a].close -> [a].send.token -> IDLE[(a+1)%N]
				  | [a].send.token -> IDLE[(a+1)%N]),
IDLE[a:Nodes] =   ( [a].recv.token -> LEADER[a]).

property OPENCLOSE = ([a:Nodes]open -> [a].close -> OPENCLOSE).

|| NOMINALRING = (NOMINALNODE || OPENCLOSE).

/**
 * ELECTIONRING
 */
NODE(I=N) = IDLE,
LEADER = (open -> close -> send.token -> IDLE
		 		| send.token -> IDLE),
IDLE = (recv.token -> LEADER
					| recv.claim[b:Nodes] -> 	if (b < I) then (send.claim[b] -> IDLE)
										else IDLE
					| send.claim[I] -> ELIGIBLE
					),
ELIGIBLE = ( recv.token -> LEADER
		   | recv.claim[b:Nodes] ->  if (I == b) then LEADER
							   else if (b < I) then (send.claim[b] -> IDLE)
							   else ELIGIBLE
		   | send.claim[I] -> ELIGIBLE) + {send.claim[Nodes]}.

CHANNEL = (send.token -> recv.token -> CHANNEL | send.claim.[a:Nodes] -> recv.claim[a] -> CHANNEL).

|| ELECTIONRING = ([a:Nodes]:NODE(a) || [b:Nodes]:CHANNEL || OPENCLOSE ) / {
	[b:Nodes].send.token / [b].tokensnd,
	[b:Nodes].recv.token / [(b+N-1)%N].tokenrcvd,
	[b:Nodes].send.claim[a:Nodes] / [b].claimsnd[a],
	[b:Nodes].recv.claim[a:Nodes] / [(b+N-1)%N].claimrcvd[a]
}.

property OPENCLOSE = ([b:Nodes].open -> [b].close -> OPENCLOSE).
